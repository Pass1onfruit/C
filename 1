转义字符：

\? 在书写连续多个问号时使用，防止他们被解析成三字母词
\' 用于表示字符常量'
\“ 用于表示一个字符串内部的双引号
\\ 用于表示一个反斜杠，防止它被解释为一个转义序列符。
\a 警告字符，蜂鸣
\b 退格符
\f 进纸符
\n 换行
\r 回车
\t 水平制表符
\v 垂直制表符
\ddd ddd表示1~3个八进制的数字。 如： \130 X
\xddd ddd表示3个十六进制数字。 如： \x030

操作符

移位操作符
<< 左移操作符 
>> 右移操作符 

左移操作符：
左边抛弃、右边补0
如：int num = 10;
//00000000000000000000000000001010
num << 1; //num = 20
//00000000000000000000000000010100

右移操作
1. 逻辑移位 左边用0填充，右边丢弃 
2. 算术移位 左边用原该值的符号位填充，右边丢弃 

对于移位运算符，不要移动负数位，这个是标准未定义的
如：num>>-1; // error 

位操作符：

&   //按位与 
|   //按位或 
^    //按位异或 
它们的操作数必须是整数

单目操作符 ：

!           逻辑反操作 
-           负值 
+           正值 
&           取地址 
sizeof      操作数的类型长度（以字节为单位） 
~           对一个数的二进制按位取反 
--          前置、后置--
++          前置、后置++
 *           间接访问操作符(解引用操作符) 
(类型)       强制类型转

隐式类型转换：
C的整型算术运算总是至少以缺省整型类型的精度来进行的。
为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为整型提升。
整型提升的意义：
表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度一般就是int 的字节长度，同时也是CPU的通用寄存器的长度
即使两个char类型进行相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度
通用CPU（general-purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令中可能有这 种字节相加指令）
所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算
整形提升是按照变量的数据类型的符号位来提升的

//负数的整形提升 
char c1 = -1; 
变量c1的二进制位(补码)中只有8个比特位： 
1111111 
因为 char 为有符号的 char 
所以整形提升的时候，高位补充符号位，即为1 
提升之后是： 
11111111111111111111111111111111
 
//正数的整形提升 
char c2 = 1; 
变量c2的二进制位(补码)中只有8个比特位： 
00000001 
因为 char 为有符号的 char 
所以整形提升的时候，高位补充符号位，即为0 
提升之后是： 
00000000000000000000000000000001
 
//无符号整形提升，高位补0

算术转换 ：

如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类型，否则操作 就无法进行
long 
double 
double 
float 
unsigned long int 
long int 
unsigned int 
int
优先级从上往下，下方的应转换成在上面的，隐式转换会有精度丢失
