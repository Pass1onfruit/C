
内存是电脑上特别重要的存储器，计算机中所有程序的运行都是在内存中进行的
所以为了有效的使用内存，就把内存划分成一个个小的内存单元，每个内存单元的大小是1个字节
为了能够有效的访问到内存的每个单元，就给内存单元进行了编号(内存编址)这些编号被称为该内存单元的内存地址

指针是编程语言中的一个对象，利用地址，它的值直接指向存在存储器中另一个位置的值
通过地址能找到所需的变量单元，可以说，地址指向该变量单元
指针是用来存放地址的，地址是唯一标示一块地址空间的
将地址形象化的称为“指针”，即通过它能找到以它为地址的内存单元

指针是个变量，存放内存单元的地址（编号）
对于32位的机器，假设有32根地址线，那么假设每根地址线在寻址的是产生一个电信号正电/负电（1或者0）那么里就有2的32次方个地址
每个地址标识一个字节，就可以给 
（2^32Byte == 2^32/1024KB == 2^32/1024/1024MB==2^32/1024/1024/1024GB == 4GB）
4G的空闲进行编址
由此知，在32位的机器上，地址是32个0或者1组成二进制序列，地址就得用4个字节的空间来存储，所以一个指针变量的大小就应该是4个字节
同理在64位机器上，如果有64个地址线，一个指针变量的大小就是8个字节

基本使用：
int num = 10; 
int *p = &num;

指针变量有相应的类型，存放不同类型变量的地址
char  *pChar = NULL; 
int   *pInt = NULL;
 short *pShorrt = NULL;
 long  *pLong = NULL; 
float *pFloat = NULL; 
double *pDouble = NULL;

引用：&p，返回p变量的地址编号
解引用：*p，返回内存地址中对应的对象
如：std::cout << *p << endl; 就是解引用操作

指针的类型决定了指针的+-整数（向前或者向后走一步）的步长
以及指针解引用操作的时候的权限（能操作几个字节）如： char* 的指针解引用 就只能访问一个字节，而 int* 的指针的解引用就能访问四个字节

指针运算 
指针 +- 整数 ：
float values[5]; 
float *vp; 
for (vp = &values[0]; vp < &values[5];) 
{   
	*vp++ = 0;
}

指针 - 指针：
int my_strlen(char *s) 
{       
	char *p = s;      
	while(*p != '\0' )              
	p++;       
	return p-s; 
}

指针的关系运算
for(vp = &values[5-1]; vp >= &values[0];vp--) 
{    
	*vp = 0; 
} 
允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与指向第一 个元素之前的那个内存位置的指针进行比较

指针数组：是存放指针的数组
数组指针：数组名表示的是数组首元素的地址
但是 arr 和 &arr 意义是不一样的，值是一样的
 &arr 表示的是数组的地址，而不是数组首元素的地址
int main()
{
	int arr[10] = { 0 };
	printf("arr = %p\n", arr);
	printf("&arr= %p\n", &arr);
	printf("arr+1 = %p\n", arr + 1);
	printf("&arr+1= %p\n", &arr + 1);
	return 0;
}
运行结果为：
arr = 004FF90C
&arr= 004FF90C
arr+1 = 004FF910
&arr+1= 004FF934
可见数组的地址+1，跳过整个数组的大小，所以 &arr+1 相对于 &arr 的差值是40

回调函数 
回调函数就是一个通过函数指针调用的函数
把函数的指针（地址）作为参数传递给另一 个函数，这个指针被用来调用其所指向的函数
回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应
