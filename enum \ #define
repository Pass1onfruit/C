 枚举：
 一个枚举是一个类型，可以保存一组由用户刻画的值。定义之类，枚举的使用很像一个整数类型。
枚举的定义具有以下形式,即以关键词enum开头，接着一个可选的枚举名，下来是由大括号{}包含着一个由逗号分隔的枚举子列表enumerators list

//enum 枚举名{枚举名 = 值,枚举名 = 值，枚举名 = 值…};
//也可以不赋值，默认会从0开始递增赋值，
//（每下一个枚举子取值是前面一个枚举子的取值+1）
//枚举最后一个元素的逗号可有可无
enum Sex 
{
	MALE,
	FEMALE,
	SECRET
};
//其中MALE=0，FEMALE=1,SECRET=2

 定义一个枚举变量时，可以给它初始化，但是不能直接地把一个整型赋值给一个枚举变量

宏：
在编译预处理时，对程序中所有定义的标识符，都用宏定义中的字符串去替换
宏定义是由源程序中的宏定义命令完成的，替换是由预处理程序自动完成的。
预处理程序对它不作任何检查
宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束，提前终止其作用域可使用#undef命令

无参宏定义：
无参宏的宏名后不带参数
#define 标识符 字符串
其中的“#”表示这是一条预处理命令（凡是以“#”开头的均为预处理命令）
宏是可以嵌套的
如：
#define a 2
#define b 3
#define ab a*b
ab 被替换为: a*b，然后又被替换成 2*3（不参与运算）

 带参宏定义
对带参数的宏，在调用中，不仅要替换字符，而且要用实参去代换形参。
#define 宏名(形参表) 字符串
在字符串中含有各个形参，形参表中形参之间可以出现空格
如：
#define max(a, b) (a>b)?a:b

如有函数
int max(a, b) { return  (a>b)?a:b;}
区别：在宏定义中的形参不分配内存单元，不作类型定义。而函数 int max(a, b)中形参是局部变量，会在栈区分配内存单元，所以要作类型定义，而且实参与形参之间是“值传递”。而宏只是符号代换，不存在值的传递。

重定义（重复包含）
头文件包含可以嵌套，所以C文件有可能包含多次同一个头文件，就可能出现重定义（看编译器）
防止一个源文件两次包含同一个头文件，两个文件要一同编译成一个可运行文件，就会有大量的声明冲突
通过条件编译开关来避免重定义，以及调整环境
例如
#ifndef “标识” //标识 一般命名规则如stdio.h 命名成_STDIO_H_
#define “标识”
…
#include <stdio.h>
//文件内容
…
#endif


比较：
1.枚举成员值可以不唯一，两个枚举成员可以具有相同的值;不能改变枚举成员的值，枚举成员是一个常量表达式，可用于需要常量表达式的任何地方

2.枚举类型对象的初始化或赋值，只能通过其枚举成员或同一枚举类型的其他对象来进行

3.enum枚举值属于常量，#define宏值不是常量

4.enum枚举具有类型，#define宏没有类型。枚举变量具有与普通变量相同的诸如作用域，值等性质，但宏没有，宏不是语言的一部分，这是一种预处理替换符

5.宏是在预处理的阶段进行替换工作的，它替换代码段的文本，程序运行的过程中宏已不存在了。而6.枚举是在程序运行之后才起作用，枚举常量存储在数据段的静态存储区里
宏占用代码段的空间，而枚举除了占用空间，还消耗CPU资源

7.宏没有作用域，宏定义后的代码都可使用这个宏。宏可以被重复定义，这可能导致宏的值被修改，所以不要用宏定义整型变量，建议用枚举或const

8.枚举和define都可以swtich，枚举是类型安全的，define不是类型安全的，枚举只能定义整形值，define能定义几乎任何值

9.枚举常量是由编译程序自动生成的，而标识符常量必须由程序员手工赋值。相比#define更方便维护

#define特点：
优点：
宏定义可为多种类型的值，如字符串、整型、浮点型等
缺点：
没有范围限制（全局范围有效），容易发生冲突，产生不确定的结果；
多个相关的值一起定义时比较散乱
适合比较少的变量时

enum特点：
缺点：
只能为整型值
优点：
遵循范围规则，不易和其它定义发生冲突
多个相关值一组，比较清晰
变量的数值在几个范围之间可以用enum
